{"name":"pluck","path":["array","pluck"],"data":"\nThe pluck function removes a number of items from an array that pass a test:\n```js\nimport { pluck } from '@benzed/array'\n\nconst arr = [ 1, 2, 3, 4, 5, 6 ]\nconst even = pluck(arr, n => n % 2 === 0)\n\nconsole.log(even) // [ 2, 4, 6 ]\nconsole.log(arr) // [ 1, 3, 5 ]\n```\n\nThe input array is mutated, and items that pass the test are returned in a new array.\n\nCan also take a count argument, which maximizes the number of elements returned:\n```js\nconst arr = [ 1, 2, 3, 4, 5, 6 ]\nconst firstTwoOdd = pluck(arr, n => n % 2 === 1, 2)\n\nconsole.log(firstTwoOdd) // [ 1, 3 ]\nconsole.log(arr) // [ 2, 4, 5, 6 ]\n```\n\nPluck is also optionally bindable:\n```js\nconst arr = [ 1, 2, 3, 4, 5, 6 ]\nconst odd = arr::pluck(n => n % 2 === 1)\n\nconsole.log(odd) // [ 1, 3, 5 ]\nconsole.log(arr) // [ 2, 4, 6 ]\n```\n","type":"md","_id":"8c0JzHaUSt4WpXSV"}
{"name":"shuffle","path":["array","shuffle"],"data":"The shuffle function randomizes the order of an array.\nMutates the array in place, does not return a new array:\n\n```js\nimport { shuffle } from '@benzed/array'\n\nconst arr = [ 1, 2, 3, 4, 5, 6 ]\nshuffle(arr)\n\nconsole.log(arr) // will now be in a random order\n```\n\nOptionally Bindable:\n```js\nconst arr = [ 1, 2, 3, 4, 5, 6 ]\narr::shuffle()\n```\n\nAlso works on strings:\n```js\nconst str = '1234578'\nstr::shuffle() // returns a randomized string\n```\n","type":"md","_id":"9UfaGTCxhcIbBr5t"}
{"name":"api","path":["dev","documentation","api"],"data":"Heading\n=======\n\n# h1\n## h2\n### h3\n#### h4\n##### h5\n###### h6\n\nParagraphs are separated\nby a blank line.\n\nTwo spaces at the end of a line  \nproduces a line break.\n\nText attributes _italic_, **bold**, `monospace`.  \n\nHorizontal rule:\n\n---\n\nBullet list:\n\n  * apples\n  * oranges\n  * pears\n\nNumbered list:\n\n  1. wash\n  2. rinse\n  3. repeat\n\nA [link][example].\n\n  [example]: http://example.com\n\n![Image](Image_icon.png \"icon\")\n\n> Markdown uses email-style\n> characters for blockquoting.\n\n```js\n\nimport Monkey from './monkey'\n\n// Code with Syntax Highlighting, as well\n\nconst result = value => (value * 2 + 1) - Infinity\nconst x = true || false\n\nclass Code extends Monkey { }\n\n```\n","type":"md","_id":"AG4qXliDd2suM92f"}
{"name":"unique","path":["array","unique"],"data":"\nThe shuffle function randomizes the order of an array.\n\nReturns the Array, mutated in place.\n\n```js\nimport { shuffle } from '@benzed/array'\n\nconst arr = [ 1, 2, 3, 4, 5, 6 ]\nshuffle(arr)\n\nconsole.log(arr) // will now be in a random order\n```\n\nOptionally Bindable:\n```js\nconst arr = [ 1, 2, 3, 4, 5, 6 ]\narr::shuffle()\n```\n\nAlso works on strings:\n```js\nconst str = '1234578'\nstr::shuffle() // returns a randomized string\n```\n","type":"md","_id":"CkBEyKN93AXNvN2D"}
{"name":"to-camel-case","path":["string","to-camel-case"],"data":"Describe the toCamelCase function.\n\n```js\nimport { toCamelCase } from '@benzed/string'\n```\n","type":"md","_id":"QLyZQksMfIkgKNXq"}
{"name":"capitalize","path":["string","capitalize"],"data":"Describe the capitalize function.\n\n```js\nimport { capitalize } from '@benzed/string'\n```\n","type":"md","_id":"RENqTPf8UYyi3KP5"}
{"name":"Services","path":["dev","documentation","api","Services"],"data":"\n# Documentation Services\n\n---\n\n```js\nimport fs from 'fs'\n```\n","type":"md","_id":"U4cGMyvBBXHSOZ6Y"}
{"name":"unwrap","path":["array","unwrap"],"data":"\n\nThe unwrap function ensures that a given value is not an array. If it is an array,\nthe first element in the array is returned:\n```js\nimport { unwrap } from '@benzed/array'\n\nconst one = unwrap([1])\n\nconsole.log(one) // 1\nconsole.log(unwrap(one)) // 1\n```\n\nOptionally Bindable:\n```js\n[1]::unwrap() // 1\n```\n","type":"md","_id":"WMuJ6SD5Bf7cEEpw"}
{"name":"styler","path":["react","util","styler"],"data":"The Styler class is a syntax shortening class that creates style functions\nfor styled components.\n\nYou wouldn't instance a Styler directly. Instead, you'd create an interface\nfor one:\n```js\nimport { Styler } from '@benzed/react'\nimport styled from 'styled-components'\n\nconst $ = Styler.createInterface()\n\nconst RedDiv = styled.div`\n  background-color: ${$.prop('color')};\n`\n// <RedDiv color='red' /> will have a red background\n```\n\nThe interface contains the same methods and properties that the class does,\nand using those properties creates new instances of stylers:\n\n```js\n$.prop('hidden')\n// equivalent to\nnew Styler().prop('hidden')\n```\n\nInterfaces can be created with a theme, which will add theme getters to\nthe resulting Styler.\n```js\nconst theme = {\n  bg: 'black',\n  fg: 'white'\n}\n\nconst $ = Styler.createInterface(theme)\n\nconst Section = styled.section`\n  background-color: ${$.theme.bg};\n  color: ${$.theme.fg};\n`\n\n// <Section /> will have be theme colored\n```\n","type":"md","_id":"Wn5QmlrzGg4Xxzn1"}
{"name":"flatten","path":["array","flatten"],"data":"The flatten function takes an Array and decomposes any nested arrays.\n\n```js\nimport { flatten } from '@benzed/array'\n\nconst flattened = flatten([1, [2], [3, [4]]])\nconsole.log(flattened) // [1, 2, 3, 4]\n```\n\nOptionally bindable:\n\n```js\nconst flattened = [1, [2]]::flatten()\nconsole.log(flattened) // [1, 2]\n```\n","type":"md","_id":"YYofx2I4DawKZGCi"}
{"name":"adjacent","path":["array","adjacent"],"data":"The adjacent function gets the neighbour of the supplied value in an array:\n```js\nimport { adjacent } from '@benzed/array'\n\nconst next = adjacent([ 'one', 'two', 'three' ], 'one')\nconsole.log(next) // 'two'\n```\n\nIf the supplied value is at the end of the array, the returned value will\nbe wrapped around:  \n```js\nconst first = adjacent([ 1, 2, 3, 4 ], 4)\nconsole.log(first) // 1\n```\n\nOptionally takes a delta argument:\n```js\nconst array = [ 'min', 1, 2, 3, 'max' ]\nconst two = adjacent(array, 'min', 2)\nconsole.log(two) // 2\n\nconst min = adjacent(array, 'max', -4)\nconsole.log(min) // 'min'\n```\n\nOptionally bindable:\n```js\nconst three = [1,2,3]::adjacent(1, 2)\nconsole.log(three) // 3\n```\n","type":"md","_id":"hw3ZwaurJEyrLQof"}
{"name":"between","path":["string","between"],"data":"The between function returns a subset of a string, that which exists between two delimeters.\n```js\nimport { between } from '@benzed/string'\n\nconst text = between('<b>bold</b>', '<b>', '</b>')\n\nconsole.log(text) // bold\n```\n\nReturns null if markers cannot be found:\n```js\nimport { between } from '@benzed/string'\n\nconst text = between('Hello world!', '{', '}')\n\nconsole.log(text) // null\n```\n","type":"md","_id":"jBZymm6lq305NC3r"}
{"name":"wrap","path":["array","wrap"],"data":"\n\nThe wrap function ensures that a given value is an array. If it is not an\narray, the value gets wrapped into one:\n```js\nimport { wrap } from '@benzed/array'\n\nconst one = wrap(1)\n\nconsole.log(one) // [1]\nconsole.log(wrap(one)) // [1]\n```\n\nOptionally Bindable:\n```js\n1::wrap() // [1]\n```\n\n","type":"md","_id":"jWm1iV3qepulIytS"}
{"name":"from-camel-case","path":["string","from-camel-case"],"data":"Describe the fromCamelCase function.\n\n```js\nimport { fromCamelCase } from '@benzed/string'\n```\n","type":"md","_id":"x4khfTCskz7UcqKD"}
{"$$deleted":true,"_id":"8c0JzHaUSt4WpXSV"}
{"$$deleted":true,"_id":"9UfaGTCxhcIbBr5t"}
{"$$deleted":true,"_id":"AG4qXliDd2suM92f"}
{"$$deleted":true,"_id":"CkBEyKN93AXNvN2D"}
{"$$deleted":true,"_id":"QLyZQksMfIkgKNXq"}
{"$$deleted":true,"_id":"RENqTPf8UYyi3KP5"}
{"$$deleted":true,"_id":"U4cGMyvBBXHSOZ6Y"}
{"$$deleted":true,"_id":"WMuJ6SD5Bf7cEEpw"}
{"$$deleted":true,"_id":"Wn5QmlrzGg4Xxzn1"}
{"$$deleted":true,"_id":"YYofx2I4DawKZGCi"}
{"$$deleted":true,"_id":"hw3ZwaurJEyrLQof"}
{"$$deleted":true,"_id":"jBZymm6lq305NC3r"}
{"$$deleted":true,"_id":"jWm1iV3qepulIytS"}
{"$$deleted":true,"_id":"x4khfTCskz7UcqKD"}
{"name":"adjacent","path":["array","adjacent"],"data":"The adjacent function gets the neighbour of the supplied value in an array:\n```js\nimport { adjacent } from '@benzed/array'\n\nconst next = adjacent([ 'one', 'two', 'three' ], 'one')\nconsole.log(next) // 'two'\n```\n\nIf the supplied value is at the end of the array, the returned value will\nbe wrapped around:  \n```js\nconst first = adjacent([ 1, 2, 3, 4 ], 4)\nconsole.log(first) // 1\n```\n\nOptionally takes a delta argument:\n```js\nconst array = [ 'min', 1, 2, 3, 'max' ]\nconst two = adjacent(array, 'min', 2)\nconsole.log(two) // 2\n\nconst min = adjacent(array, 'max', -4)\nconsole.log(min) // 'min'\n```\n\nOptionally bindable:\n```js\nconst three = [1,2,3]::adjacent(1, 2)\nconsole.log(three) // 3\n```\n","type":"md","_id":"VblMHm0T0aUTKBbR"}
{"name":"flatten","path":["array","flatten"],"data":"The flatten function takes an Array and decomposes any nested arrays.\n\n```js\nimport { flatten } from '@benzed/array'\n\nconst flattened = flatten([1, [2], [3, [4]]])\nconsole.log(flattened) // [1, 2, 3, 4]\n```\n\nOptionally bindable:\n\n```js\nconst flattened = [1, [2]]::flatten()\nconsole.log(flattened) // [1, 2]\n```\n","type":"md","_id":"sF8u9P2QJdO6GSSj"}
{"name":"pluck","path":["array","pluck"],"data":"\nThe pluck function removes a number of items from an array that pass a test:\n```js\nimport { pluck } from '@benzed/array'\n\nconst arr = [ 1, 2, 3, 4, 5, 6 ]\nconst even = pluck(arr, n => n % 2 === 0)\n\nconsole.log(even) // [ 2, 4, 6 ]\nconsole.log(arr) // [ 1, 3, 5 ]\n```\n\nThe input array is mutated, and items that pass the test are returned in a new array.\n\nCan also take a count argument, which maximizes the number of elements returned:\n```js\nconst arr = [ 1, 2, 3, 4, 5, 6 ]\nconst firstTwoOdd = pluck(arr, n => n % 2 === 1, 2)\n\nconsole.log(firstTwoOdd) // [ 1, 3 ]\nconsole.log(arr) // [ 2, 4, 5, 6 ]\n```\n\nPluck is also optionally bindable:\n```js\nconst arr = [ 1, 2, 3, 4, 5, 6 ]\nconst odd = arr::pluck(n => n % 2 === 1)\n\nconsole.log(odd) // [ 1, 3, 5 ]\nconsole.log(arr) // [ 2, 4, 6 ]\n```\n","type":"md","_id":"nRuhyoNOgN0fObaS"}
{"name":"api","path":["dev","documentation","api"],"data":"Heading\n=======\n\n# h1\n## h2\n### h3\n#### h4\n##### h5\n###### h6\n\nParagraphs are separated\nby a blank line.\n\nTwo spaces at the end of a line  \nproduces a line break.\n\nText attributes _italic_, **bold**, `monospace`.  \n\nHorizontal rule:\n\n---\n\nBullet list:\n\n  * apples\n  * oranges\n  * pears\n\nNumbered list:\n\n  1. wash\n  2. rinse\n  3. repeat\n\nA [link][example].\n\n  [example]: http://example.com\n\n![Image](Image_icon.png \"icon\")\n\n> Markdown uses email-style\n> characters for blockquoting.\n\n```js\n\nimport Monkey from './monkey'\n\n// Code with Syntax Highlighting, as well\n\nconst result = value => (value * 2 + 1) - Infinity\nconst x = true || false\n\nclass Code extends Monkey { }\n\n```\n","type":"md","_id":"dn5cJOY9K6oypp75"}
{"name":"shuffle","path":["array","shuffle"],"data":"The shuffle function randomizes the order of an array.\nMutates the array in place, does not return a new array:\n\n```js\nimport { shuffle } from '@benzed/array'\n\nconst arr = [ 1, 2, 3, 4, 5, 6 ]\nshuffle(arr)\n\nconsole.log(arr) // will now be in a random order\n```\n\nOptionally Bindable:\n```js\nconst arr = [ 1, 2, 3, 4, 5, 6 ]\narr::shuffle()\n```\n\nAlso works on strings:\n```js\nconst str = '1234578'\nstr::shuffle() // returns a randomized string\n```\n","type":"md","_id":"B7quoFnYhcUA7tS7"}
{"name":"between","path":["string","between"],"data":"The between function returns a subset of a string, that which exists between two delimeters.\n```js\nimport { between } from '@benzed/string'\n\nconst text = between('<b>bold</b>', '<b>', '</b>')\n\nconsole.log(text) // bold\n```\n\nReturns null if markers cannot be found:\n```js\nimport { between } from '@benzed/string'\n\nconst text = between('Hello world!', '{', '}')\n\nconsole.log(text) // null\n```\n","type":"md","_id":"dRr60KPU7odhOVQF"}
{"name":"capitalize","path":["string","capitalize"],"data":"Describe the capitalize function.\n\n```js\nimport { capitalize } from '@benzed/string'\n```\n","type":"md","_id":"jy99MZYwPi4KCMeU"}
{"name":"Services","path":["dev","documentation","api","Services"],"data":"\n# Documentation Services\n\n---\n\n```js\nimport fs from 'fs'\n```\n","type":"md","_id":"sdH0qoXvxpLrT9QD"}
{"name":"unique","path":["array","unique"],"data":"\nThe shuffle function randomizes the order of an array.\n\nReturns the Array, mutated in place.\n\n```js\nimport { shuffle } from '@benzed/array'\n\nconst arr = [ 1, 2, 3, 4, 5, 6 ]\nshuffle(arr)\n\nconsole.log(arr) // will now be in a random order\n```\n\nOptionally Bindable:\n```js\nconst arr = [ 1, 2, 3, 4, 5, 6 ]\narr::shuffle()\n```\n\nAlso works on strings:\n```js\nconst str = '1234578'\nstr::shuffle() // returns a randomized string\n```\n","type":"md","_id":"NSGOjb6UiX0Ho0Fk"}
{"name":"from-camel-case","path":["string","from-camel-case"],"data":"Describe the fromCamelCase function.\n\n```js\nimport { fromCamelCase } from '@benzed/string'\n```\n","type":"md","_id":"wUeNyjNKOJazgrM9"}
{"name":"wrap","path":["array","wrap"],"data":"\n\nThe wrap function ensures that a given value is an array. If it is not an\narray, the value gets wrapped into one:\n```js\nimport { wrap } from '@benzed/array'\n\nconst one = wrap(1)\n\nconsole.log(one) // [1]\nconsole.log(wrap(one)) // [1]\n```\n\nOptionally Bindable:\n```js\n1::wrap() // [1]\n```\n\n","type":"md","_id":"FD3GUktGhai58bgw"}
{"name":"to-camel-case","path":["string","to-camel-case"],"data":"Describe the toCamelCase function.\n\n```js\nimport { toCamelCase } from '@benzed/string'\n```\n","type":"md","_id":"e2pFsC8EM3lxx2mS"}
{"name":"styler","path":["react","util","styler"],"data":"The Styler class is a syntax shortening class that creates style functions\nfor styled components.\n\nYou wouldn't instance a Styler directly. Instead, you'd create an interface\nfor one:\n```js\nimport { Styler } from '@benzed/react'\nimport styled from 'styled-components'\n\nconst $ = Styler.createInterface()\n\nconst RedDiv = styled.div`\n  background-color: ${$.prop('color')};\n`\n// <RedDiv color='red' /> will have a red background\n```\n\nThe interface contains the same methods and properties that the class does,\nand using those properties creates new instances of stylers:\n\n```js\n$.prop('hidden')\n// equivalent to\nnew Styler().prop('hidden')\n```\n\nInterfaces can be created with a theme, which will add theme getters to\nthe resulting Styler.\n```js\nconst theme = {\n  bg: 'black',\n  fg: 'white'\n}\n\nconst $ = Styler.createInterface(theme)\n\nconst Section = styled.section`\n  background-color: ${$.theme.bg};\n  color: ${$.theme.fg};\n`\n\n// <Section /> will have be theme colored\n```\n","type":"md","_id":"5ZUohywPqPFTgbAH"}
{"name":"unwrap","path":["array","unwrap"],"data":"\n\nThe unwrap function ensures that a given value is not an array. If it is an array,\nthe first element in the array is returned:\n```js\nimport { unwrap } from '@benzed/array'\n\nconst one = unwrap([1])\n\nconsole.log(one) // 1\nconsole.log(unwrap(one)) // 1\n```\n\nOptionally Bindable:\n```js\n[1]::unwrap() // 1\n```\n","type":"md","_id":"fLeaWNREMps9BTML"}
